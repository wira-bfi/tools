<!doctype html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lora Tools</title>

  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsonpath@1.1.1/jsonpath.min.js"></script>

  <!-- DaisyUI + Tailwind CSS -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.24/dist/full.min.css" rel="stylesheet" type="text/css" />
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    #cy {
      width: 100%;
      height: 400px;
      background: oklch(var(--b2));
      border-radius: var(--rounded-box);
    }

    .highlight {
      background-color: #fbbf24;
      color: #000;
      font-weight: bold;
      padding: 0 2px;
      border-radius: 2px;
    }
  </style>
</head>

<body class="bg-base-200 min-h-screen p-4">
  <div class="max-w-7xl mx-auto">
    <!-- Header -->
    <div class="navbar bg-base-100 rounded-box shadow-lg mb-4">
      <div class="flex-1">
        <span class="text-xl font-bold px-4">üîß Lora Tools</span>
      </div>
      <div class="flex-none">
        <button id="theme-toggle" class="btn btn-ghost btn-circle" onclick="toggleTheme()">
          <svg id="sun-icon" class="fill-current w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path
              d="M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z" />
          </svg>
          <svg id="moon-icon" class="fill-current w-6 h-6 hidden" xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24">
            <path
              d="M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Tabs -->
    <div role="tablist" class="tabs tabs-boxed bg-base-100 mb-4 p-1">
      <button type="button" id="tab-visualizer" class="tab tab-active" onclick="showTab('visualizer')">
        üìä Doc Revision Visualizer
      </button>
      <button type="button" id="tab-readset" class="tab" onclick="showTab('readset')">
        üìã ReadSet Checker
      </button>
    </div>

    <!-- Tab Panels -->
    <!-- Visualizer Panel -->
    <div id="panel-visualizer" class="space-y-4">
      <!-- Input Section -->
      <div class="card bg-base-100 shadow-lg">
        <div class="card-body p-4">
          <h2 class="card-title text-sm">Input Internal Doc Revision</h2>
          <textarea id="lastdocrev" class="textarea textarea-bordered w-full font-mono text-xs" rows="3"
            placeholder="Paste your Internal Doc Revision JSON here..."></textarea>
        </div>
      </div>

      <!-- Graph and Info Grid -->
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
        <!-- Cytoscape Graph -->
        <div class="lg:col-span-2 card bg-base-100 shadow-lg">
          <div class="card-body p-4">
            <div class="flex items-center justify-between mb-2">
              <h2 class="card-title text-sm">Revision Graph</h2>
              <input type="text" id="graph-search" placeholder="Search node..."
                class="input input-bordered input-sm w-48" />
            </div>
            <div id="cy" class="border border-base-300 rounded-lg"></div>
          </div>
        </div>

        <!-- Info Panels -->
        <div class="space-y-4">
          <div class="collapse collapse-arrow bg-base-100 shadow-lg">
            <input type="checkbox" checked />
            <div class="collapse-title font-medium text-sm">üìñ Read Set</div>
            <div class="collapse-content pr-4">
              <div id="readSet" class="text-xs text-base-content/70 max-h-32 overflow-auto">
                <p class="italic">Click a node to see read set</p>
              </div>
            </div>
          </div>

          <div class="collapse collapse-arrow bg-base-100 shadow-lg">
            <input type="checkbox" checked />
            <div class="collapse-title font-medium text-sm">‚úèÔ∏è Write Set</div>
            <div class="collapse-content pr-4">
              <div id="writeSet" class="text-xs text-base-content/70 max-h-32 overflow-auto">
                <p class="italic">Click a node to see write set</p>
              </div>
            </div>
          </div>

          <div class="collapse collapse-arrow bg-base-100 shadow-lg">
            <input type="checkbox" checked />
            <div class="collapse-title font-medium text-sm">üîÑ Data Changed</div>
            <div class="collapse-content pr-4">
              <div id="diffToLastDoc" class="text-xs text-base-content/70 max-h-32 overflow-auto">
                <p class="italic">Click a node to see diff</p>
              </div>
            </div>
          </div>

          <div class="collapse collapse-arrow bg-base-100 shadow-lg border-l-4 border-error">
            <input type="checkbox" checked />
            <div class="collapse-title font-medium text-sm">‚ö†Ô∏è Rollback Info</div>
            <div class="collapse-content">
              <div id="rollbackInfo" class="text-xs text-base-content/70 max-h-48 overflow-auto">
                <p class="italic">Load data to see rollback analysis</p>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Document Preview -->
      <div class="card bg-base-100 shadow-lg">
        <div class="card-body p-4">
          <div class="flex items-center justify-between mb-2">
            <h2 class="card-title text-sm">üìÑ Document</h2>
          </div>
          <div class="form-control">
            <input type="text" id="document-search" placeholder="Search in document..."
              class="input input-bordered input-sm w-full mb-2" />
          </div>
          <div id="document" class="text-xs text-base-content/70 max-h-48 overflow-auto">
            <p class="italic">Click a node to see document</p>
          </div>
        </div>
      </div>
    </div>

    <!-- ReadSet Checker Panel -->
    <div id="panel-readset" class="hidden">
      <div class="card bg-base-100 shadow-lg">
        <div class="card-body p-4 space-y-4">
          <div class="flex flex-col gap-1 text-sm text-base-content/70">
            <div class="flex items-center gap-2">
              <span class="badge badge-ghost">Last sync:</span>
              <span id="last-sync-time">-</span>
            </div>
            <div class="flex items-center gap-2" id="git-info-container" style="display: none;">
              <span class="badge badge-ghost">Commit:</span>
              <a id="git-commit-link" href="#" target="_blank" class="link link-primary font-mono text-xs">-</a>
            </div>
          </div>

          <div class="form-control w-full">
            <label class="label">
              <span class="label-text">Document Type</span>
            </label>
            <div class="dropdown w-full">
              <input type="text" id="doctype-search" placeholder="Search document type..."
                class="input input-bordered w-full" autocomplete="off" />
              <ul id="doctype-dropdown" tabindex="0"
                class="dropdown-content menu bg-base-100 rounded-box z-50 w-full max-h-60 overflow-auto shadow-lg border border-base-300 hidden">
              </ul>
            </div>
            <input type="hidden" id="doctype" />
          </div>

          <div class="form-control w-full">
            <label class="label">
              <span class="label-text">Doc Revision</span>
            </label>
            <textarea id="docrev" class="textarea textarea-bordered w-full font-mono text-xs" rows="6"
              placeholder="Paste your Doc Revision JSON here..."></textarea>
          </div>

          <div class="divider">Result</div>

          <div id="readset-checker" class="p-4 bg-base-200 rounded-lg min-h-24">
            <p class="italic text-sm text-base-content/70">Enter doc revision to check...</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // Global State
    // ============================================
    let currentTheme = localStorage.getItem('theme') || 'light';

    // ============================================
    // Theme Toggle (Global function for onclick)
    // ============================================
    function toggleTheme() {
      currentTheme = currentTheme === 'light' ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', currentTheme);
      localStorage.setItem('theme', currentTheme);
      updateThemeIcons();
    }

    function updateThemeIcons() {
      const sunIcon = document.getElementById('sun-icon');
      const moonIcon = document.getElementById('moon-icon');
      if (currentTheme === 'dark') {
        sunIcon.classList.add('hidden');
        moonIcon.classList.remove('hidden');
      } else {
        sunIcon.classList.remove('hidden');
        moonIcon.classList.add('hidden');
      }
    }

    // ============================================
    // Tab Navigation (Global function for onclick)
    // ============================================
    function showTab(tabName) {
      // Update tab buttons
      document.getElementById('tab-visualizer').classList.toggle('tab-active', tabName === 'visualizer');
      document.getElementById('tab-readset').classList.toggle('tab-active', tabName === 'readset');

      // Update panels
      document.getElementById('panel-visualizer').classList.toggle('hidden', tabName !== 'visualizer');
      document.getElementById('panel-readset').classList.toggle('hidden', tabName !== 'readset');
    }

    // ============================================
    // ReadSet Checker Module
    // ============================================
    const ReadSetChecker = {
      readsets: [],
      constants: {},
      dataToCompare: {},
      currentType: null,

      async init() {
        try {
          const response = await fetch('readset-output.json');
          const data = await response.json();

          this.readsets = data.readSets;
          this.constants = data.constants;

          document.getElementById('last-sync-time').textContent = data.extractedAt;

          // Display git info if available
          if (data.gitInfo) {
            const gitContainer = document.getElementById('git-info-container');
            const gitLink = document.getElementById('git-commit-link');
            gitContainer.style.display = 'flex';
            gitLink.textContent = data.gitInfo.shortCommitId;
            gitLink.href = data.gitInfo.commitUrl;
            gitLink.title = data.gitInfo.commitId;
          }

          this.populateDocTypes(data.readSets);
          this.bindEvents();
        } catch (error) {
          console.error('Failed to load readset data:', error);
        }
      },

      populateDocTypes(readSets) {
        this.allTypes = readSets.map(r => r.type);
        this.currentType = readSets[0]?.type;

        const searchInput = document.getElementById('doctype-search');
        const dropdown = document.getElementById('doctype-dropdown');
        const hiddenInput = document.getElementById('doctype');

        // Set initial value
        if (this.currentType) {
          searchInput.value = this.currentType;
          hiddenInput.value = this.currentType;
        }

        // Render dropdown options
        this.renderDropdownOptions(this.allTypes);
      },

      renderDropdownOptions(types) {
        const dropdown = document.getElementById('doctype-dropdown');
        dropdown.innerHTML = types.map(type =>
          `<li><a class="doctype-option" data-value="${type}">${type}</a></li>`
        ).join('');
      },

      bindEvents() {
        document.getElementById('docrev').addEventListener('input', (e) => {
          try {
            const rawData = JSON.parse(e.target.value);
            this.dataToCompare = this.sanitizeKeys(rawData);
            this.check();
          } catch (err) {
            this.showError('Invalid JSON');
          }
        });

        const searchInput = document.getElementById('doctype-search');
        const dropdown = document.getElementById('doctype-dropdown');
        const hiddenInput = document.getElementById('doctype');

        // Show dropdown on focus
        searchInput.addEventListener('focus', () => {
          dropdown.classList.remove('hidden');
          this.renderDropdownOptions(this.allTypes);
        });

        // Filter options on input
        searchInput.addEventListener('input', (e) => {
          const query = e.target.value.toLowerCase();
          const filtered = this.allTypes.filter(type =>
            type.toLowerCase().includes(query)
          );
          this.renderDropdownOptions(filtered);
          dropdown.classList.remove('hidden');
        });

        // Handle option selection
        dropdown.addEventListener('click', (e) => {
          if (e.target.classList.contains('doctype-option')) {
            const value = e.target.dataset.value;
            searchInput.value = value;
            hiddenInput.value = value;
            this.currentType = value;
            dropdown.classList.add('hidden');
            this.check();
          }
        });

        // Hide dropdown on click outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.dropdown')) {
            dropdown.classList.add('hidden');
          }
        });

        // Keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            dropdown.classList.add('hidden');
          }
        });
      },

      sanitizeKeys(obj) {
        if (Array.isArray(obj)) return obj.map(item => this.sanitizeKeys(item));
        if (obj !== null && typeof obj === 'object') {
          return Object.keys(obj).reduce((acc, key) => {
            const cleanKey = key.replace(/[\[\]\*]/g, '');
            acc[cleanKey] = this.sanitizeKeys(obj[key]);
            return acc;
          }, {});
        }
        return obj;
      },

      check() {
        if (!this.currentType || Object.keys(this.dataToCompare).length === 0) return;

        const readset = this.readsets.find(r => r.type === this.currentType);
        if (!readset) return;

        const missingData = readset.readSet.filter(v => {
          const path = this.constants[v];
          return jsonpath.query(this.dataToCompare, path).length === 0;
        }).map(v => this.constants[v]);

        this.showResult(missingData);
      },

      showResult(missingData) {
        const container = document.getElementById('readset-checker');
        if (missingData.length === 0) {
          container.innerHTML = `
                        <div class="alert alert-success">
                            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            <span>All fields present!</span>
                        </div>`;
        } else {
          container.innerHTML = `
                        <div class="alert alert-warning">
                            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                            </svg>
                            <div>
                                <h3 class="font-bold">Missing ${missingData.length} field(s)</h3>
                                <pre class="text-xs mt-2 overflow-auto">${JSON.stringify(missingData, null, 2)}</pre>
                            </div>
                        </div>`;
        }
      },

      showError(message) {
        document.getElementById('readset-checker').innerHTML = `
                    <div class="alert alert-error">
                        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span>${message}</span>
                    </div>`;
      }
    };

    // ============================================
    // Doc Revision Visualizer Module
    // ============================================
    const DocVisualizer = {
      cy: null,
      nodeKeysByNode: [],
      requestData: null,
      setData: {},

      init() {
        document.getElementById('lastdocrev').addEventListener('input', (e) => {
          try {
            this.requestData = JSON.parse(e.target.value);
            this.render();
          } catch (err) {
            console.error('Invalid JSON:', err);
          }
        });

        // Document search functionality
        document.getElementById('document-search').addEventListener('input', (e) => {
          this.filterDocument(e.target.value);
        });

        // Graph node search functionality
        document.getElementById('graph-search').addEventListener('input', (e) => {
          this.searchNodes(e.target.value);
        });
      },

      searchNodes(query) {
        if (!this.cy) return;

        // Normalize query: replace spaces with underscores, lowercase
        const normalizedQuery = query.toLowerCase().replace(/\s+/g, '_').trim();

        // Reset all nodes
        this.cy.nodes().removeClass('search-match search-dim');

        if (!normalizedQuery) return;

        // Find matching nodes (search in original ID)
        const matchingNodes = this.cy.nodes().filter(node => {
          const nodeId = node.id().toLowerCase();
          return nodeId.includes(normalizedQuery);
        });

        if (matchingNodes.length > 0) {
          // Dim non-matching nodes
          this.cy.nodes().addClass('search-dim');
          matchingNodes.removeClass('search-dim').addClass('search-match');

          // Center on first match
          this.cy.animate({
            fit: { eles: matchingNodes, padding: 50 },
            duration: 300
          });
        }
      },

      render() {
        const req = this.requestData;
        req[1].history.nodes.shift();

        const nodesWithSetData = [
          { set_data: {} },
          ...req[1].history.nodes.filter(node => Object.keys(node).length > 0)
        ];

        this.setData = {};
        this.nodeKeysByNode = this.mapNodeKeys(nodesWithSetData);

        const edges = this.buildEdges();
        const nodes = this.buildNodes();

        // Analyze rollbacks
        this.rollbackData = this.analyzeRollbacks();

        this.initCytoscape(nodes, edges);
        this.displayRollbackSummary();
      },

      analyzeRollbacks() {
        const req = this.requestData;
        const cache = req[1].history.cache;
        const nodes = req[1].history.nodes;

        // Build flat list of all process executions with their index
        const processExecutions = [];
        nodes.forEach((nodeGroup, idx) => {
          for (const processName of Object.keys(nodeGroup)) {
            processExecutions.push({
              index: idx,
              name: processName,
              readHash: nodeGroup[processName].read_hash,
              writeHash: nodeGroup[processName].write_hash
            });
          }
        });

        // Find processes that appear multiple times with different read_hash (= rollback happened)
        const processOccurrences = {};
        processExecutions.forEach((exec, i) => {
          if (!processOccurrences[exec.name]) {
            processOccurrences[exec.name] = [];
          }
          processOccurrences[exec.name].push({ ...exec, execIndex: i });
        });

        const rollbackEvents = [];

        for (const [processName, occurrences] of Object.entries(processOccurrences)) {
          if (occurrences.length <= 1) continue; // No rollback if only one occurrence

          // For each pair of consecutive occurrences
          for (let i = 0; i < occurrences.length - 1; i++) {
            const firstRun = occurrences[i];
            const rerun = occurrences[i + 1];

            // If read_hash is different, rollback occurred
            if (firstRun.readHash !== rerun.readHash) {
              // Find processes that ran between firstRun and rerun
              const processesBetween = processExecutions.filter(
                p => p.index > firstRun.index && p.index < rerun.index
              );

              // Find which process changed the input values
              const firstReadData = cache[firstRun.readHash]?.value || {};
              const rerunReadData = cache[rerun.readHash]?.value || {};

              // Find changed values
              const changedValues = {};
              const allKeys = new Set([...Object.keys(firstReadData), ...Object.keys(rerunReadData)]);
              for (const key of allKeys) {
                const oldVal = JSON.stringify(firstReadData[key]);
                const newVal = JSON.stringify(rerunReadData[key]);
                if (oldVal !== newVal) {
                  changedValues[key] = {
                    oldValue: firstReadData[key],
                    newValue: rerunReadData[key]
                  };
                }
              }

              // Find which process wrote the changed values (take the LAST one for accuracy)
              let causingProcess = null;
              const changedKeys = Object.keys(changedValues);

              // Iterate in reverse to find the last process that wrote the changed values
              for (let j = processesBetween.length - 1; j >= 0; j--) {
                const proc = processesBetween[j];
                const writeData = cache[proc.writeHash]?.value || {};
                const writtenKeys = Object.keys(writeData);

                // Check if this process wrote any of the changed keys
                const overlap = writtenKeys.filter(k => changedKeys.includes(k));
                if (overlap.length > 0) {
                  // Get the actual values written
                  const writtenValues = {};
                  for (const key of overlap) {
                    writtenValues[key] = writeData[key];
                  }

                  causingProcess = {
                    name: proc.name,
                    nodeIndex: proc.index,
                    writeHash: proc.writeHash,
                    fieldsWritten: overlap,
                    writtenValues: writtenValues,
                    allFieldsWritten: writtenKeys
                  };
                  break; // Take the last (most recent) process that caused the change
                }
              }

              rollbackEvents.push({
                rolledBackProcess: processName,
                firstRunIndex: firstRun.index,
                rerunIndex: rerun.index,
                causingProcess: causingProcess,
                changedInputValues: changedValues,
                processesBetween: processesBetween.map(p => p.name)
              });
            }
          }
        }

        // Sort by historical order (firstRunIndex)
        rollbackEvents.sort((a, b) => a.firstRunIndex - b.firstRunIndex);

        return rollbackEvents;
      },

      displayRollbackSummary() {
        const container = document.getElementById('rollbackInfo');

        if (!this.rollbackData || this.rollbackData.length === 0) {
          container.innerHTML = '<p class="text-success">‚úÖ No rollbacks detected</p>';
          return;
        }

        // Group by causingProcess
        const groupedByCause = {};
        for (const rb of this.rollbackData) {
          const causeName = rb.causingProcess?.name || '_unknown';
          if (!groupedByCause[causeName]) {
            groupedByCause[causeName] = {
              causingProcess: rb.causingProcess,
              events: []
            };
          }
          groupedByCause[causeName].events.push(rb);
        }

        // Count unique causes
        const causeCount = Object.keys(groupedByCause).length;

        let html = `
          <div class="mb-2">
            <span class="badge badge-error">${this.rollbackData.length} rollback event(s)</span>
            <span class="badge badge-warning ml-1">${causeCount} cause(s)</span>
          </div>
        `;

        // Sort causes by nodeIndex (historical order)
        const sortedCauses = Object.entries(groupedByCause).sort((a, b) => {
          const idxA = a[1].causingProcess?.nodeIndex ?? 999999;
          const idxB = b[1].causingProcess?.nodeIndex ?? 999999;
          return idxA - idxB;
        });

        for (const [causeName, data] of sortedCauses) {
          const { causingProcess, events } = data;

          // Sort events by firstRunIndex
          events.sort((a, b) => a.firstRunIndex - b.firstRunIndex);

          html += `
            <div class="mb-3 p-2 bg-base-200 rounded border-l-4 border-error">
              <div class="font-semibold text-error">üî• ${causeName === '_unknown' ? 'Unknown Cause' : causeName}</div>
              ${causingProcess ? `<div class="text-xs opacity-70">at node index ${causingProcess.nodeIndex}</div>` : ''}
              
              ${causingProcess?.writtenValues ? `
                <details class="mt-2 bg-error/10 p-2 rounded" open>
                  <summary class="cursor-pointer text-xs font-medium text-error">üìã Fields written by this process (${causingProcess.fieldsWritten.length})</summary>
                  <div class="text-xs mt-1 max-h-32 overflow-auto">
                    ${Object.entries(causingProcess.writtenValues).map(([key, val]) => `
                      <div class="mb-1 p-1 bg-base-300 rounded">
                        <div class="opacity-70 truncate" title="${key}">${key}</div>
                        <div class="text-success font-mono">${JSON.stringify(val)}</div>
                      </div>
                    `).join('')}
                  </div>
                </details>
              ` : ''}
              
              <div class="text-xs mt-2">Affected <span class="font-bold">${events.length}</span> process(es):</div>
              
              <div class="mt-2 space-y-2">
                ${events.map(rb => {
            const changedKeys = Object.keys(rb.changedInputValues || {});
            return `
                    <div class="p-2 bg-base-300 rounded">
                      <div class="font-medium text-warning text-sm">üîÑ ${rb.rolledBackProcess}</div>
                      <div class="text-xs opacity-70">Node: ${rb.firstRunIndex} ‚Üí ${rb.rerunIndex}</div>
                      
                      <details class="mt-1" open>
                        <summary class="cursor-pointer text-xs">üìù Changed values (${changedKeys.length})</summary>
                        <div class="text-xs ml-2 mt-1 max-h-48 overflow-auto">
                          ${changedKeys.map(key => {
              const change = rb.changedInputValues[key];
              const oldStr = JSON.stringify(change.oldValue);
              const newStr = JSON.stringify(change.newValue);
              return `
                              <div class="mb-1 p-1 bg-base-200 rounded">
                                <div class="opacity-70 truncate" title="${key}">${key}</div>
                                <div class="flex flex-wrap gap-1">
                                  <span class="text-error">${oldStr || 'null'}</span>
                                  <span>‚Üí</span>
                                  <span class="text-success">${newStr || 'null'}</span>
                                </div>
                              </div>
                            `;
            }).join('')}
                        </div>
                      </details>
                    </div>
                  `;
          }).join('')}
              </div>
            </div>
          `;
        }

        container.innerHTML = html;
      },

      mapNodeKeys(nodes) {
        const uniqueKeys = new Set();

        const getUniqueKey = (baseKey) => {
          let counter = 1;
          let candidate = `${baseKey}_${counter}`;
          while (uniqueKeys.has(candidate)) {
            counter++;
            candidate = `${baseKey}_${counter}`;
          }
          uniqueKeys.add(candidate);
          return candidate;
        };

        return nodes.map(node =>
          Object.keys(node).map(key => ({
            name: getUniqueKey(key),
            readHash: node[key].read_hash,
            writeHash: node[key].write_hash
          }))
        );
      },

      buildEdges() {
        const edges = [];
        for (let i = 0; i < this.nodeKeysByNode.length - 1; i++) {
          for (const fromKey of this.nodeKeysByNode[i]) {
            for (const toKey of this.nodeKeysByNode[i + 1]) {
              edges.push({
                data: {
                  id: `${fromKey.name}_${toKey.name}`,
                  source: fromKey.name,
                  target: toKey.name
                }
              });
            }
          }
        }
        return edges;
      },

      buildNodes() {
        // Get processes affected by rollback
        const rollbackTriggers = new Set();
        const rollbackAffected = new Set();
        if (this.rollbackData) {
          for (const rb of this.rollbackData) {
            if (rb.causingProcess?.name) {
              rollbackTriggers.add(rb.causingProcess.name);
            }
            if (rb.rolledBackProcess) {
              rollbackAffected.add(rb.rolledBackProcess);
            }
          }
        }

        const nodes = [];
        const nodeSpacingX = 160;
        const nodeSpacingY = 130;

        this.nodeKeysByNode.forEach((layer, layerIndex) => {
          const layerSize = layer.length;
          const layerStartY = -(layerSize - 1) * nodeSpacingY / 2; // Center vertically

          layer.forEach((nodeData, nodeIndex) => {
            const nodeName = nodeData.name;
            const baseName = nodeName.replace(/_\d+$/, '');

            let nodeClass = '';
            if (nodeName.includes('set_data')) nodeClass = 'green-node';
            else if (rollbackTriggers.has(baseName)) nodeClass = 'rollback-trigger-node';
            else if (rollbackAffected.has(baseName)) nodeClass = 'rollback-affected-node';
            else if (nodeName.match(/^(survey|review)_\d$/)) nodeClass = 'yellow-node';

            // Create display label: replace underscores with newlines for wrapping
            const displayLabel = nodeName.replace(/_/g, '\n');

            nodes.push({
              data: { id: nodeName, label: displayLabel },
              position: {
                x: layerIndex * nodeSpacingX + 50,
                y: layerStartY + nodeIndex * nodeSpacingY + 300
              },
              ...(nodeClass && { classes: nodeClass })
            });
          });
        });

        return nodes;
      },

      initCytoscape(nodes, edges) {
        this.cy = cytoscape({
          container: document.getElementById('cy'),
          elements: [...nodes, ...edges],
          style: this.getCytoscapeStyles(),
          layout: this.getCytoscapeLayout()
        });

        this.bindCytoscapeEvents();
      },

      getCytoscapeStyles() {
        return [
          {
            selector: 'node',
            style: {
              'background-color': '#6366f1',
              'background-opacity': 0.95,
              'label': 'data(label)',
              'text-valign': 'center',
              'text-halign': 'center',
              'color': '#ffffff',
              'font-size': '9px',
              'font-weight': '600',
              'font-family': 'system-ui, -apple-system, sans-serif',
              'width': 110,
              'height': 90,
              'shape': 'round-rectangle',
              'border-width': 2,
              'border-color': '#4f46e5',
              'text-wrap': 'wrap',
              'text-max-width': '110px',
              'text-outline-width': 0,
              'overlay-padding': '6px',
              'z-index': 10,
              'transition-property': 'background-color, width, height',
              'transition-duration': '0.15s'
            }
          },
          {
            selector: 'node:hover',
            style: {
              'background-color': '#4f46e5',
              'border-color': '#6366f1',
              'width': 95,
              'height': 95,
              'cursor': 'pointer'
            }
          },
          {
            selector: 'node.selected',
            style: {
              'background-color': '#f43f5e',
              'width': 75,
              'height': 75,
              'border-width': 3,
              'border-color': '#fff',
              'border-opacity': 0.8,
              'z-index': 20
            }
          },
          {
            selector: 'edge',
            style: {
              'width': 1.5,
              'line-color': '#d1d5db',
              'target-arrow-color': '#d1d5db',
              'target-arrow-shape': 'triangle',
              'arrow-scale': 0.8,
              'curve-style': 'bezier',
              'opacity': 0.6,
              'transition-property': 'line-color, width, opacity',
              'transition-duration': '0.2s'
            }
          },
          {
            selector: 'edge.highlighted',
            style: {
              'width': 2.5,
              'line-color': '#f43f5e',
              'target-arrow-color': '#f43f5e',
              'opacity': 1,
              'z-index': 15
            }
          },
          {
            selector: '.green-node',
            style: {
              'background-color': '#10b981',
              'background-opacity': 0.9
            }
          },
          {
            selector: '.yellow-node',
            style: {
              'background-color': '#f59e0b',
              'background-opacity': 0.9,
              'color': '#ffffff'
            }
          },
          {
            selector: '.rollback-trigger-node',
            style: {
              'background-color': '#ef4444',
              'background-opacity': 0.95,
              'border-width': 3,
              'border-color': '#fbbf24',
              'border-style': 'dashed'
            }
          },
          {
            selector: '.rollback-affected-node',
            style: {
              'background-color': '#f97316',
              'background-opacity': 0.9,
              'border-width': 2,
              'border-color': '#fbbf24'
            }
          },
          {
            selector: '.search-match',
            style: {
              'border-width': 4,
              'border-color': '#22c55e',
              'z-index': 100
            }
          },
          {
            selector: '.search-dim',
            style: {
              'opacity': 0.3
            }
          }
        ];
      },

      getCytoscapeLayout() {
        return {
          name: 'preset', // Use fixed positions from node.position
          fit: true,
          padding: 30,
          animate: false
        };
      },

      bindCytoscapeEvents() {
        this.cy.on('tap', 'node', (evt) => {
          const node = evt.target;
          this.cy.elements().removeClass('selected highlighted');
          node.addClass('selected');
          node.connectedEdges().addClass('highlighted');
          // Use node.id() which contains the original name, not label (which has newlines)
          this.updateNodeInfo(node.id());
        });

        this.cy.on('tap', (evt) => {
          if (evt.target === this.cy) {
            this.cy.elements().removeClass('selected highlighted');
            this.clearNodeInfo();
          }
        });
      },

      updateNodeInfo(nodeLabel) {
        const req = this.requestData;

        // Find node object
        let nodeObj = null;
        for (const nodeArr of this.nodeKeysByNode) {
          nodeObj = nodeArr.find(n => n.name === nodeLabel);
          if (nodeObj) break;
        }

        // Build document state
        const { doc, lastDiff, setData } = this.buildDocumentState(nodeLabel);
        this.setData = setData;

        // Format data as styled list like Rollback Info
        const formatData = (data, title) => {
          if (!data || Object.keys(data).length === 0) {
            return '<p class="text-xs opacity-50 italic">No data</p>';
          }

          const entries = Object.entries(data.value || data);
          return `
            <div class="text-xs">
              <div class="badge badge-sm mb-2">${entries.length} field(s)</div>
              <div class="max-h-48 overflow-auto space-y-1">
                ${entries.map(([key, val]) => `
                  <div class="p-1 bg-base-200 rounded">
                    <div class="opacity-70 truncate text-xs" title="${key}">${key}</div>
                    <div class="text-success font-mono text-xs">${JSON.stringify(val)}</div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        };

        if (nodeLabel?.includes('set_data')) {
          document.getElementById('readSet').innerHTML = '<p class="text-xs opacity-50 italic">No data</p>';
          document.getElementById('writeSet').innerHTML = formatData(setData[nodeLabel] || {});
          document.getElementById('diffToLastDoc').innerHTML = formatData(setData[nodeLabel] || {});
        } else if (nodeLabel && nodeObj) {
          document.getElementById('readSet').innerHTML = formatData(req[1].history.cache[nodeObj.readHash] || {});
          document.getElementById('writeSet').innerHTML = formatData(req[1].history.cache[nodeObj.writeHash] || {});
          document.getElementById('diffToLastDoc').innerHTML = formatData(lastDiff);
        }

        // Store for search functionality
        this.documentData = doc;
        document.getElementById('document').innerHTML = formatData(doc);
      },

      buildDocumentState(nodeLabel) {
        const req = this.requestData;
        const doc = {};
        const rawDoc = {};
        let lastDiff = {};
        const setData = {};
        const fields = Object.keys(req[1].fields);

        // Parse field history
        const regex = /^\s*\[(?<name>[a-z0-9_]+)(\-\S+)?:\(true:(?<value>.*)\)\]\s*$/;

        fields.forEach(field => {
          rawDoc[field] = [];
          const history = req[1].fields[field].value.desc
            .split('-->')
            .filter(x => x !== 'chain: (nil) ' && !x.includes('__rollback'))
            .map(x => {
              const result = x.match(regex);
              if (result) {
                return {
                  name: result.groups.name === '__external' ? 'set_data' : result.groups.name,
                  value: result.groups.value
                };
              }
            });

          if (history.length > 0) rawDoc[field] = history;
          else doc[field] = null;
        });

        // Process nodes
        const allNodes = [[{ name: '__internal' }], ...this.nodeKeysByNode];

        for (const nodeArr of allNodes) {
          for (const y of nodeArr) {
            const normalize = y.name.replace(/_\d+$/, '');
            const diff = {};

            const filteredFields = Object.keys(rawDoc).filter(
              field => rawDoc[field].length > 0 && rawDoc[field][0]?.name === normalize
            );

            if (y.writeHash) {
              const writeSet = Object.keys(req[1].history.cache[y.writeHash]?.value || {});
              for (const f of filteredFields) {
                if (writeSet.includes(f)) {
                  const res = rawDoc[f].shift();
                  if (doc[f] !== res?.value) diff[f] = res?.value;
                  doc[f] = res?.value;
                }
              }
            } else {
              for (const f of filteredFields) {
                const res = rawDoc[f].shift();
                if (y.name.includes('set_data')) {
                  if (!setData[y.name]) setData[y.name] = {};
                  setData[y.name][f] = res?.value;
                }
                if (doc[f] !== res?.value) diff[f] = res?.value;
                doc[f] = res?.value;
              }
            }

            if (y.name === nodeLabel) {
              lastDiff = diff;
              break;
            }
          }
        }

        return { doc, lastDiff, setData };
      },

      clearNodeInfo() {
        const placeholder = '<p class="italic">Click a node to view</p>';
        document.getElementById('readSet').innerHTML = placeholder;
        document.getElementById('writeSet').innerHTML = placeholder;
        document.getElementById('diffToLastDoc').innerHTML = placeholder;
        document.getElementById('document').innerHTML = placeholder;
        document.getElementById('document-search').value = '';
      },

      filterDocument(searchTerm) {
        if (!this.documentData || Object.keys(this.documentData).length === 0) return;

        const docElement = document.getElementById('document');
        const search = searchTerm.trim().toLowerCase();

        if (search === '') {
          // No search term, show all
          docElement.innerHTML = this.formatDataForDisplay(this.documentData);
          return;
        }

        // Filter the data
        const filtered = {};
        for (const [key, value] of Object.entries(this.documentData)) {
          const keyMatch = key.toLowerCase().includes(search);
          const valMatch = JSON.stringify(value).toLowerCase().includes(search);
          if (keyMatch || valMatch) {
            filtered[key] = value;
          }
        }

        if (Object.keys(filtered).length === 0) {
          docElement.innerHTML = '<p class="text-xs opacity-50 italic">No matches found</p>';
        } else {
          docElement.innerHTML = this.formatDataForDisplay(filtered);
        }
      },

      formatDataForDisplay(data) {
        if (!data || Object.keys(data).length === 0) {
          return '<p class="text-xs opacity-50 italic">No data</p>';
        }

        const entries = Object.entries(data);
        return `
          <div class="text-xs">
            <div class="badge badge-sm mb-2">${entries.length} field(s)</div>
            <div class="max-h-48 overflow-auto space-y-1">
              ${entries.map(([key, val]) => `
                <div class="p-1 bg-base-200 rounded">
                  <div class="opacity-70 truncate text-xs" title="${key}">${key}</div>
                  <div class="text-success font-mono text-xs">${JSON.stringify(val)}</div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      },

      filterObject(obj, searchTerm) {
        if (typeof obj !== 'object' || obj === null) {
          return String(obj).toLowerCase().includes(searchTerm) ? obj : null;
        }

        if (Array.isArray(obj)) {
          const filtered = obj.map(item => this.filterObject(item, searchTerm)).filter(item => item !== null);
          return filtered.length > 0 ? filtered : null;
        }

        const result = {};
        for (const [key, value] of Object.entries(obj)) {
          // Check if key matches
          if (key.toLowerCase().includes(searchTerm)) {
            result[key] = value;
            continue;
          }

          // Check if value matches
          if (typeof value === 'object' && value !== null) {
            const filtered = this.filterObject(value, searchTerm);
            if (filtered !== null && (Array.isArray(filtered) ? filtered.length > 0 : Object.keys(filtered).length > 0)) {
              result[key] = filtered;
            }
          } else if (String(value).toLowerCase().includes(searchTerm)) {
            result[key] = value;
          }
        }

        return result;
      }
    };

    // ============================================
    // Initialize Application
    // ============================================
    document.addEventListener('DOMContentLoaded', () => {
      // Apply saved theme
      document.documentElement.setAttribute('data-theme', currentTheme);
      updateThemeIcons();

      // Initialize modules
      ReadSetChecker.init();
      DocVisualizer.init();
    });
  </script>
</body>

</html>